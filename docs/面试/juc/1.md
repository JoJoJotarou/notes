# 如何保证线程的安全？

线程的安全从以下三点考虑：

- 可见性
- 有序性
- 原子性

其中可见性和有序性由 volatile 关键字保证，原子性由 `synchronized` 之类的锁和原子类保证。

## 可见性

Java 内存模型：每个线程都有自己独立的本地内存，线程从主内存中读取数据加载到本地内存，然后才可以使用数据，若发生更新先更新本地内存变量副本，再将同步回主内存中。

Java 内存模型中定义了 8 大原子操作：

- read
- load
- use
- assign
- store
- wirte
- lock
- unlock

假设现在有 2 个线程（A、B），它们都从主内存中读取变量 X=1，其中线程A，只使用变量 X, 线程B会更新X的值为，由于变量 X 做任何特殊处理，在将X=2 同步回主线程时，线程A 并不能知道变量X被修改了。这样造成了线程可见性的问题。

### 缓存一致性协议（MESI）

在物理层面同样会出现相同的问题，因为CPU和内存的速度差距非常的大，CPU 设计了多层缓存来缓解速度差距带来的效率问题。缓存一致性协议规定，当线程修改了变量需马上同步主线程，并则利用总线嗅探机制，将其他线程的改变量标记为失效。这样，当其他线程继续使用改变量时就会重新从主内存中获取该变量。

如何实现？

通过汇编指令 lock 前缀实现的，lock 会锁定操作变量所在的缓存行，将其回写到主内存中，同时引发其他CPU中存储了该内存地址的数据无效。

java 底层会为 volatile 修饰的变量添加 lock，这样是线程B修改了变量X后，其他线程也能够及时感知到变量修改了。

## 有序性

同样是 CPU 和内存的速度差距非常大的问题，CPU 通过指令重排序这项技术来提高CPU 的使用效率。

指令重排序指在不改变单线程执行结果的前提下，CPU 可以调整指令执行的先后顺序。

指令重排序有个非常形象的类比，接水，烧水，洗茶杯，喝茶 这四件事本来是一次执行的，但是由于烧水需要比较长的时间，那么，可以在烧水时提前完成洗茶杯的动作。

### 内存屏障

内存屏障规定屏障前后的指令的执行顺序不能够重排序。

x86指令集中定义了如下三个屏障：

- lfence：读屏障
- sfence：写屏障
- mfence：读写屏障

Java 内存模型中也定了内存屏障：

- loadload：读读屏障
- loadstore：读写屏障
- storeload：写读屏障
- storestore：写写屏障

lock 指令同样提供内存屏障的功能，是指令无法重排。所以 volatile 也保证了有序性。

- 在每个volatile写操作的前面插入一个StoreStore屏障。
- 在每个volatile写操作的后面插入一个StoreLoad屏障。
- 在每个volatile读操作的后面插入一个LoadLoad屏障。
- 在每个volatile读操作的后面插入一个LoadStore屏障。

## 原子性

synchronized、Lock

## more

1. 无状态设计 线程安全问题是由多线程并发修改共享变量引起的,如果在并发环境中没有设计共享变量,则自然就不会出现线程安全问题了。这种代码实现可以称作“无状态实现”,所谓状态就是指共享变量。
2. 不可变设计 如果在并发环境中不得不设计共享变量,则应该优先考虑共享变量是否为只读的,如果是只读场景就可以将共享变量设计为不可变的,这样自然也不会出现线程安全问题了。具体来说,就是在变量前加final修饰符,使其不可被修改,如果变量是引用类型,则将其设计为不可变类型（参考String类）。
3. 并发工具 java.util.concurrent包提供了几个有用的并发工具类,一样可以保证线程安全： - Semaphore：就是信号量,可以控制同时访问特定资源的线程数量。 - CountDownLatch：允许一个或多个线程等待其他线程完成操作。 - CyclicBarrier：让一组线程到达一个屏障时被阻塞,直到最后一个线程到达屏障时,屏障才会打开,所有被屏障拦截的线程才会继续运行。
4. 本地存储 我们也可以考虑使用ThreadLocal存储变量,ThreadLocal可以很方便地为每一个线程单独存一份数据,也就是将需要并发访问的资源复制成多份。这样一来,就可以避免多线程访问共享变量了,它们访问的是自己独占的资源,它从根本上隔离了多个线程之间的数据共享。
